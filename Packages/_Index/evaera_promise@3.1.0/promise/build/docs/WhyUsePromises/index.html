<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">Why use Promises? | roblox-lua-promise</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://eryn.io/roblox-lua-promise/docs/WhyUsePromises"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Why use Promises? | roblox-lua-promise"><meta data-react-helmet="true" name="description" content="Before diving in to Promises themselves, you might need some convincing of why we should even use Promises to begin with. That&#x27;s totally fair! The following text should give you a brief introduction to Promises and a good understanding of why they are useful."><meta data-react-helmet="true" property="og:description" content="Before diving in to Promises themselves, you might need some convincing of why we should even use Promises to begin with. That&#x27;s totally fair! The following text should give you a brief introduction to Promises and a good understanding of why they are useful."><link data-react-helmet="true" rel="canonical" href="https://eryn.io/roblox-lua-promise/docs/WhyUsePromises"><link data-react-helmet="true" rel="alternate" href="https://eryn.io/roblox-lua-promise/docs/WhyUsePromises" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://eryn.io/roblox-lua-promise/docs/WhyUsePromises" hreflang="x-default"><link rel="stylesheet" href="/roblox-lua-promise/assets/css/styles.82660294.css">
<link rel="preload" href="/roblox-lua-promise/assets/js/runtime~main.06bd307d.js" as="script">
<link rel="preload" href="/roblox-lua-promise/assets/js/main.d1498228.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/roblox-lua-promise/"><b class="navbar__title">roblox-lua-promise</b></a><a class="navbar__item navbar__link navbar__link--active" href="/roblox-lua-promise/docs/intro">Docs</a><a class="navbar__item navbar__link" href="/roblox-lua-promise/api/">API</a><a class="navbar__item navbar__link" href="/roblox-lua-promise/changelog">Changelog</a></div><div class="navbar__items navbar__items--right"><a href="https://discord.gg/ECEDZbFXnE" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/evaera/roblox-lua-promise" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Press S to Search..." aria-label="Search" class="navbar__search-input search-bar"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/roblox-lua-promise/docs/intro">Getting Started with Promises</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/roblox-lua-promise/docs/Installation">Installation</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/roblox-lua-promise/docs/Tour">Tour of Promises</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/roblox-lua-promise/docs/WhyUsePromises">Why use Promises?</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/roblox-lua-promise/docs/Examples">Examples</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Why use Promises?</h1></header><p>Before diving in to Promises themselves, you might need some convincing of why we should even use Promises to begin with. That&#x27;s totally fair! The following text should give you a brief introduction to Promises and a good understanding of why they are useful.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="threads"></a>Threads<a class="hash-link" href="#threads" title="Direct link to heading">#</a></h2><p>When writing programs, it&#x27;s possible to divide functions into two groups: &quot;synchronous&quot; and &quot;asynchronous&quot;. A &quot;synchronous operation&quot; is one that can run to completion and generate any necessary return values with only the information available to your code at the time the operation begins. For example, a function that takes two Parts and returns the distance between them would be synchronous, because all information needed to compute that value is available when you call the function.</p><p>But sometimes situations arise where we call a function that needs access to a value that <em>doesn&#x27;t</em> exist at call time. This could be because it requires a network request to get the data, or the user needs to input some text, or we&#x27;re waiting for another process to finish computation and give us the value. In any case, we refer to this as an &quot;asynchronous operation&quot;.</p><p>The simplest way to deal with this is to just stop execution of the thread, or &quot;block&quot;. This means that when you call a function that needs some data that doesn&#x27;t exist yet, the entire thread stops running and waits for the data to be ready before returning and continuing. This is actually how many low-level languages typically model asynchronous operations. To allow tasks to run at the same time, programs will create new threads that branch from parent threads and jump back on when they&#x27;re finished blocking. However, this presents challenges with sharing memory and synchronizing data across threads, because at the operating system level threads truly are running in parallel.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="coroutines"></a>Coroutines<a class="hash-link" href="#coroutines" title="Direct link to heading">#</a></h2><p>To simplify sharing memory and potentially reduce overhead, many programs will emulate a multi-threaded environment using green threads or coroutines, which are run concurrently inside of one OS thread. The key difference between OS threads and coroutines is that coroutines do not <em>actually</em> run in parallel -- only one coroutine is ever executing at a time. In the context of Lua, the term &quot;thread&quot; is used to refer to a coroutine, but they are not the same thing as OS threads.</p><p>To facilitate this emulation, a thread scheduler is introduced to keep track of the emulated threads and decide which thread to run next when the current thread yields. Yielding is similar to blocking, except when a coroutine yields, it signals to the thread scheduler that it can run other code and resume the thread at a later time.</p><p>When the game starts, each Script and LocalScript in your game becomes its own Lua thread in the thread scheduler and each script is run either to completion or until it yields. Once all of the scripts have gone through this process, Roblox does other things like updating humanoids and running physics. After all that&#x27;s done, the next frame begins and this process repeats until the game closes.</p><p>So, what really happens when we call an asynchronous function like <code>Player:IsInGroup</code>? Well, the current Lua thread yields (letting other Lua code start running elsewhere in your game), and Roblox makes a new OS thread which blocks on an HTTP request to their internal group APIs in the background. Sometime in the future when that request comes back, the value jumps back onto the main Roblox thread and your Lua thread is scheduled to be resumed with the given arguments on the next step.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="problems-with-the-coroutine-model"></a>Problems with the Coroutine Model<a class="hash-link" href="#problems-with-the-coroutine-model" title="Direct link to heading">#</a></h2><p>Coroutines fix the memory sharing problem of OS threads, but they still inherit other problems when used on their own:</p><ul><li>It&#x27;s impossible to know if a function that you call is going to yield or not unless you look at the documentation or strictly abide by a naming convention (which is not realistic). Unintentionally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into.</li><li>When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful, and make composing multiple asynchronous operations difficult.</li><li>It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery.</li><li>Coroutines lack easy access to introspection without manual work to enable it at the call site.</li><li>Coroutines lack the ability to cancel an operation if the value is no longer needed without extraneous manual work at both the call site and the function implementation.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="enter-promises"></a>Enter Promises<a class="hash-link" href="#enter-promises" title="Direct link to heading">#</a></h2><p>In Lua, Promises are an abstraction over coroutines. A &quot;Promise&quot; is just an object which we can use to represent a value that exists in the future, but doesn&#x27;t right now. Promises are first-class citizens in other languages like JavaScript, which doesn&#x27;t have coroutines and facilitates all asynchronous code through callbacks alone.</p><p>When calling an asynchronous function, instead of yielding, the function returns a Promise synchronously. The Promise object allows you to then attach a callback function which will be run later when the Promise <em>resolves</em>. The function you called is in charge of resolving the Promise with your value when it is done working.</p><p>Promises also have built-in error handling. In addition to resolving, a Promise can <em>reject</em>, which means that something went wrong when getting the future value we asked for. You can attach a different callback to be run when the Promise rejects so you can handle any error cases.</p><p>Let&#x27;s take a look at this in action. We will make a function which wraps <code>HttpService:GetAsync</code> and instead of yielding, it will return a Promise.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">local HttpService = game:GetService(&quot;HttpService&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">local function httpGet(url)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Promise.new(function(resolve, reject)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        local ok, result = pcall(HttpService.GetAsync, HttpService, url)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if ok then</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            resolve(result)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        else</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            reject(result)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        end</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Let&#x27;s break this down. The <code>Promise.new</code> function accepts a function, called an <em>executor</em>, which receives a <code>resolve</code> function and a <code>reject</code> function. <code>Promise.new</code> calls the executor on the next Lua step. <strong>Inside it, we have created a safe space to safely call yielding functions, which has no possibility of unintentionally delaying other parts of your code</strong>. Since the Promise value itself was already returned from the <code>httpGet</code> function, we aren&#x27;t delaying the return by yielding with <code>GetAsync</code>.</p><p>Let&#x27;s use the value now:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">local promise = httpGet(&quot;https://google.com&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">promise:andThen(function(body)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;Here&#x27;s the Google homepage:&quot;, body)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">promise:catch(function(err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    warn(&quot;We failed to get the Google homepage!&quot;, err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>So, we call the <code>andThen</code> method on the Promise returned from <code>httpGet</code>. If the Promise resolved, the handler we passed into <code>andThen</code> is called and given the resolved values as parameters (<code>body</code> in this example). </p><p>Likewise, we attach a failure handler with <code>catch</code> to be run if the Promise rejects.</p><p>But wait! In addition to attaching a callback, <code>andThen</code> and <code>catch</code> also return <em>new</em> Promises themselves! If the original Promise rejects, then the Promise returned from <code>andThen</code> will <em>also</em> reject with the same error, allowing is to rewrite our code like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">httpGet(&quot;https://google.com&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(function(body)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        print(&quot;Here&#x27;s the Google homepage:&quot;, body)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :catch(function(err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        warn(&quot;We failed to get the Google homepage!&quot;, err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The Promise returned from <code>andThen</code> will resolve with whatever value you return from the callback. </p><p>And if that value returned from the <code>andThen</code> handler is itself a Promise, it is automatically chained onto and the Promise returned from <code>andThen</code> won&#x27;t resolve until <em>that</em> Promise resolves.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">httpGet(&quot;https://google.com&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(function(body) -- not doing anything with body for this example</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return httpGet(&quot;https://eryn.io&quot;) -- returning a new Promise here!</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(function(body) -- Doesn&#x27;t get called until the above Promise resolves!</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        print(&quot;Here&#x27;s the eryn.io homepage:&quot;, body)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :catch(warn) -- Still catches errors from both Promises!</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="composing-promises"></a>Composing Promises<a class="hash-link" href="#composing-promises" title="Direct link to heading">#</a></h2><p>Promises are <em>composable</em>. This means that Promises can easily be used, interact with, and consume one another without manually threading values between them. We already saw above how returning a Promise from the <code>andThen</code> handler will chain onto it. Let&#x27;s expand that idea by diving into some more ways you can compose Promises with each other:</p><p>Let&#x27;s assume that we have a number of asynchronous functions which all return Promises, <code>async1</code>, <code>async2</code>, <code>async3</code>, <code>async3</code>, etc. Calling one of these functions will return a Promise. But what if we want to call all of them in sequence, each one after the one before it finishes? It&#x27;s as simple as this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">async1()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async2)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async3)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async4)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async5)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :catch(function(err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        warn(&quot;Oh no! This went wrong somewhere along the line:&quot;, err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>In this sample, we first call <code>async1</code>, then we chain the rest of the functions together with <code>andThen</code>. If <em>any</em> of the Promises returned from these functions <em>reject</em>, then all remaining <code>andThen</code>&#x27;d functions are skipped and it will jump instantly to the <code>catch</code> handler. </p><p>And as a side note, if you forget to add a <code>catch</code> to a long chain of Promises and one of them errors, the Promise library is smart enough to emit a warning in the console. Always catch your Promises!</p><p>Let&#x27;s think of another situation. What if we want to run all of the functions concurrently, and wait for all of them to be done? We don&#x27;t want to run them one after another, because sometimes that can be wasteful. We want them all to run at once! We can do this with the static method <code>Promise.all</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Promise.all({</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    async1(),</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    async2(),</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    async3(),</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    async4()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}):andThen(function(arrayOfResolvedValues)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;Done running all 4 functions!&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end):catch(function(err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    warn(&quot;Uh oh, one of the Promises rejected! Abort mission!&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><code>Promise.all</code> accepts an array of Promise objects, and returns a new Promise. The new Promise will <em>resolve</em> with an array of resolved values in the same places as the Promises were in the array. The new Promise will <em>reject</em> if <em>any</em> of the Promises that were passed in rejects.</p><p><a href="https://eryn.io/roblox-lua-promise/lib/#race" target="_blank" rel="noopener noreferrer"><code>Promise.race</code></a> is similar to <code>Promise.all</code>, except it will resolve or reject as soon as one of the Promises resolves or rejects.</p><p>We can call functions that return Promises from inside a Promise and safely yield for their result by using the <code>await</code> method of Promises. This is akin to the <code>await</code> keyword in languages like JavaScript. Sometimes it might be easier to just directly resolve with a Promise though, in which case that Promise is chained onto and the outer Promise won&#x27;t resolve until the inner one does.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">local function async1()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Promise.new(function(resolve, reject)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        local ok, value = async2():await()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if not ok then</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return reject(value)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        end</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        resolve(value + 1)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="wait-nevermind"></a>Wait, nevermind.<a class="hash-link" href="#wait-nevermind" title="Direct link to heading">#</a></h2><p>Sometimes, we no longer need a value that we previously asked for (or we just want to stop a sequence of events). This could be for a variety of reasons: perhaps the user closed a menu that was loading,  or a player&#x27;s ability gets interrupted, or a player skips a cutscene.</p><p>When situations like these come up, we can <em>cancel</em> a Promise. Cancelling a Promise in its simplest form prevents the <code>andThen</code> or <code>catch</code> handlers from running. But we can also optionally attach a hook inside of the Promise executor so we know when the Promise has been cancelled, and stop doing work.</p><p>There is a third parameter sent to Promise executors, in addition to <code>resolve</code> and <code>reject</code>, called <code>onCancel</code>. <code>onCancel</code> allows you to register a callback which will be called whenever the Promise is cancelled. For example:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">local function tween(obj, tweenInfo, props)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return Promise.new(function(resolve, reject, onCancel)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        local tween = TweenService:Create(obj, tweenInfo, props)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        -- Register a callback to be called if the Promise is cancelled.</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        onCancel(function()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            tween:Cancel()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        end) </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        tween.Completed:Connect(resolve)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        tween:Play()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">-- Begin tweening immediately</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">local promise = tween(workspace.Part, TweenInfo.new(2), { Transparency = 0.5 }):andThen(function()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;This is never printed.&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end):catch(function()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;This is never printed.&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end):finally(function()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    print(&quot;But this *is* printed!&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">wait(1)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">promise:cancel() -- Cancel the Promise, which cancels the tween.</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>If we didn&#x27;t register an <code>onCancel</code> callback, the Promise returned from the <code>tween</code> would never resolve or reject (so the <code>andThen</code> and <code>catch</code> handlers would never get called), but the tween would still finish.</p><p>For times when we need to do something no matter the fate of the Promise, whether it gets resolved, rejected, <em>or</em> cancelled, we can use <code>finally</code>. <code>finally</code> is like <code>andThen</code> and <code>catch</code>, except it <em>always</em> runs whenever the Promise is done running.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="propagation"></a>Propagation<a class="hash-link" href="#propagation" title="Direct link to heading">#</a></h2><p>Cancelling a Promise will propagate upwards and cancel the entire chain of Promises. So to revisit our sequence example:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">local promise = async1()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async2)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async3)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async4)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :andThen(async5)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    :catch(function(err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        warn(&quot;Oh no! This went wrong somewhere along the line:&quot;, err)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    end)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">promise:cancel()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Cancelling <code>promise</code> (which is the Promise that <code>catch</code> returns here) will end up cancelling every Promise in the chain, all the way up to the Promise returned by <code>async1</code>. The reason this happens is because if we cancel the bottom-most Promise, we are no longer doing anything with the value, which means that no one is doing anything with the value from the Promise above it either, and so on all the way to the top. However, Promises will <em>not</em> be cancelled if they have more than one <code>andThen</code> handler attached to them, unless all of those are also cancelled.</p><p>Cancellation also propagates downwards. If a Promise is cancelled, and other Promises are dependent on that Promise, there&#x27;s no way they could resolve or reject anymore, so they are cancelled as well. </p><p>So, now we understand the four possible states a Promise can be in: Started (running), Resolved, Rejected, and Cancelled. It&#x27;s possible to read what state a Promise is in by calling <code>promise:getStatus()</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="but-i-want-to-be-able-to-use-pre-existing-functions-that-yield"></a>But I want to be able to use pre-existing functions that yield!<a class="hash-link" href="#but-i-want-to-be-able-to-use-pre-existing-functions-that-yield" title="Direct link to heading">#</a></h2><p>You can easily turn a yielding function into a Promise-returning one by calling <code>Promise.promisify</code> on it:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly lua"><pre tabindex="0" class="prism-code language-lua codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">-- Assuming myFunctionAsync is a function that yields.</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">local myFunction = Promise.promisify(myFunctionAsync)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">myFunction(&quot;some&quot;, &quot;arguments&quot;):andThen(print):catch(warn)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="problems-revisited"></a>Problems, revisited<a class="hash-link" href="#problems-revisited" title="Direct link to heading">#</a></h2><p>Now, let&#x27;s revisit the problems we laid about before and see if we&#x27;ve solved them by using Promises:</p><ul><li>It&#x27;s impossible to know if a function that you call is going to yield or not.<ul><li>Calling a function that returns a Promise will never yield! To use the value, we must call <code>andThen</code> or <code>await</code>, so we are sure that the caller knows that this is an asynchronous operation.</li></ul></li><li>When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same patterns.<ul><li>We have <code>Promise:catch</code> to allow catching errors that will cascade down a Promise chain and jump to the nearest <code>catch</code> handler.</li></ul></li><li>It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery.<ul><li>We have <code>Promise.all</code>, <code>Promise.race</code>, or other utilities to make this a breeze.</li></ul></li><li>Coroutines lack easy access to introspection without manual work to enable it at the call site.<ul><li>We can just call <code>:getStatus</code> on the returned Promise!</li></ul></li><li>Coroutines lack the ability to cancel an operation if the value is no longer needed without extraneous manual work at both the call site and the function implementation.<ul><li><code>promise:cancel()</code> is all we need!</li></ul></li></ul><p>Another point that&#x27;s important to drive home is that you <em>can</em> do all of these things without Promises, but they require duplicated work each time you do them, which makes them incompatible with each other and that allows for slight differences between implementations which can lead to usage mistakes. Centralizing and abstracting all of this logic by using Promises ensures that all of your asynchronous APIs will be consistent and composable with one another.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="next-steps"></a>Next steps<a class="hash-link" href="#next-steps" title="Direct link to heading">#</a></h2><p>Now that you are hopefully convinced of the benefits of using Promises in your code, move on to the <a href="/roblox-lua-promise/docs/Tour">Guide</a> for a quick introduction, or dive in to the <a href="/roblox-lua-promise/api/Promise">API reference</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/evaera/roblox-lua-promise/edit/master/docs/WhyUsePromises.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/roblox-lua-promise/docs/Tour"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Tour of Promises</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/roblox-lua-promise/docs/Examples"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Examples Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#threads" class="table-of-contents__link">Threads</a></li><li><a href="#coroutines" class="table-of-contents__link">Coroutines</a></li><li><a href="#problems-with-the-coroutine-model" class="table-of-contents__link">Problems with the Coroutine Model</a></li><li><a href="#enter-promises" class="table-of-contents__link">Enter Promises</a></li><li><a href="#composing-promises" class="table-of-contents__link">Composing Promises</a></li><li><a href="#wait-nevermind" class="table-of-contents__link">Wait, nevermind.</a></li><li><a href="#propagation" class="table-of-contents__link">Propagation</a></li><li><a href="#but-i-want-to-be-able-to-use-pre-existing-functions-that-yield" class="table-of-contents__link">But I want to be able to use pre-existing functions that yield!</a></li><li><a href="#problems-revisited" class="table-of-contents__link">Problems, revisited</a></li><li><a href="#next-steps" class="table-of-contents__link">Next steps</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2021 evaera. Built with Moonwave and Docusaurus.</div></div></div></footer></div>
<script src="/roblox-lua-promise/assets/js/runtime~main.06bd307d.js"></script>
<script src="/roblox-lua-promise/assets/js/main.d1498228.js"></script>
</body>
</html>