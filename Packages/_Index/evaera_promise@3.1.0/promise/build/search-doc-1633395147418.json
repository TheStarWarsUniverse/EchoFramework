[{"title":"Error","type":0,"sectionRef":"#","url":"api/Error","content":"On this page Error An object to represent runtime errors that occur during execution. Promises that experience an error like this will be rejected with an instance of this object.","keywords":""},{"title":"Getting Started with Promises","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started with Promises Here are some quick links to get started using Promises: Installation guideAPI DocsTour of PromisesWhy use Promises at all?Examples","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method 1 - Quick and Dirty","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---quick-and-dirty","content":"In Roblox Studio, select the folder where you keep your third party modules / utilities.Run this in the command bar:  local Http = game:GetService(&quot;HttpService&quot;) local HttpEnabled = Http.HttpEnabled Http.HttpEnabled = true local m = Instance.new(&quot;ModuleScript&quot;) m.Parent = game:GetService(&quot;Selection&quot;):Get()[1] or game:GetService(&quot;ServerScriptService&quot;) m.Name = &quot;Promise&quot; m.Source = Http:GetAsync(&quot;https://raw.githubusercontent.com/evaera/roblox-lua-promise/master/lib/init.lua&quot;) game:GetService(&quot;Selection&quot;):Set({m}) Http.HttpEnabled = HttpEnabled  "},{"title":"Method 2 - Manual","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---manual","content":"Visit the latest releaseUnder Assets, click Promise.lua Using Rojo? Put the file into your game directly.Using Roblox Studio? Open the file, copy its contents, and paste into a ModuleScript and call it Promise. "},{"title":"Method 3 - Git Submodule","type":1,"pageTitle":"Installation","url":"docs/Installation#method-3---git-submodule","content":"Add the Promise repository as a git submodule (ideally within a folder called submodules) (tutorial here)Update your Rojo configuration to point to the appropriate path and sync the file in. "},{"title":"Method 4 - Package Manager","type":1,"pageTitle":"Installation","url":"docs/Installation#method-4---package-manager","content":"Using a package manager? The repository has a rotriever.toml. "},{"title":"Next","type":1,"pageTitle":"Installation","url":"docs/Installation#next","content":"Now, check out the API reference! "},{"title":"Examples","type":0,"sectionRef":"#","url":"docs/Examples","content":"","keywords":""},{"title":"Chaining","type":1,"pageTitle":"Examples","url":"docs/Examples#chaining","content":"Chain together multiple Promise-returning functions, and only handle a potential error once. If any function rejects in the chain, execution will jump down to catch.  doSomething() :andThen(doSomethingElse) :andThen(doSomethingOtherThanThat) :andThen(doSomethingAgain) :catch(print) Copy "},{"title":"IsInGroup wrapper","type":1,"pageTitle":"Examples","url":"docs/Examples#isingroup-wrapper","content":"This function demonstrates how to convert a function that yields into a function that returns a Promise. (Assuming you don't want to use Promise.promisify) local function isPlayerInGroup(player, groupId) return Promise.new(function(resolve) resolve(player:IsInGroup(groupId)) end)end Copy "},{"title":"TweenService wrapper","type":1,"pageTitle":"Examples","url":"docs/Examples#tweenservice-wrapper","content":"This function demonstrates convert a Roblox API that uses events into a function that returns a Promise. local function tween(obj, tweenInfo, props) return function() return Promise.new(function(resolve, reject, onCancel) local tween = TweenService:Create(obj, tweenInfo, props) if onCancel(function() tween:Cancel() end) then return end tween.Completed:Connect(resolve) tween:Play() end) endend Copy "},{"title":"Cancellable animation sequence","type":1,"pageTitle":"Examples","url":"docs/Examples#cancellable-animation-sequence","content":"The following is an example of an animation sequence which is composable and cancellable. If the sequence is cancelled, the animated part will instantly jump to the end position as if it had played all the way through. We use Promise.doneCall, which uses done internally, instead of andThen because we want the Promises to run even if the Promise is cancelled. We handle the case of the Promise being cancelled with the onCancel function. We take advantage of Promise chaining by returning Promises from the done handler functions. Because of this behavior, cancelling the final Promise in the chain will propagate up to the very top and cancel every single Promise you see here. local Promise = require(game.ReplicatedStorage.Promise)local TweenService = game:GetService(&quot;TweenService&quot;) local sleep = Promise.promisify(wait) local function apply(obj, props) for key, value in pairs(props) do obj[key] = value endend local function runTween(obj, props) return Promise.new(function(resolve, reject, onCancel) local tween = TweenService:Create(obj, TweenInfo.new(0.5), props) if onCancel(function() tween:Cancel() apply(obj, props) end) then return end tween.Completed:Connect(resolve) tween:Play() end)end local function runAnimation(part, intensity) return Promise.resolve() :doneCall(sleep, 1) :doneCall(runTween, part, { Reflectance = 1 * intensity }):doneCall(runTween, part, { CFrame = CFrame.new(part.Position) * CFrame.Angles(0, math.rad(90 * intensity), 0) }):doneCall(runTween, part, { Size = ( Vector3.new(10, 10, 10) * intensity ) + Vector3.new(1, 1, 1) })end local animation = Promise.resolve() -- Begin Promise chain :doneCall(runAnimation, workspace.Part, 1) :doneCall(sleep, 1) :doneCall(runAnimation, workspace.Part, 0) :catch(warn) wait(2)animation:cancel() -- Remove this line to see the full animation Copy "},{"title":"Tour of Promises","type":0,"sectionRef":"#","url":"docs/Tour","content":"","keywords":""},{"title":"Creating a Promise","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#creating-a-promise","content":"There are a few ways to create a Promise. The most common way is to call Promise.new: local myFunction() return Promise.new(function(resolve, reject, onCancel) somethingThatYields() resolve(&quot;Hello world!&quot;) end)end myFunction():andThen(print) Copy Another example which resolves a Promise after the first time an event fires: tip There's actually a built-in function called Promise.fromEvent that does exactly this! local myFunction() return Promise.new(function(resolve, reject, onCancel) local connection connection = someEvent:Connect(function(...) connection:Disconnect() resolve(...) end) onCancel(function() connection:Disconnect() end) end)end myFunction():andThen(print) Copy If you just want to wrap a single value in a Promise, you can use Promise.resolve: local myFunction() return Promise.resolve(&quot;Hello world!&quot;)end myFunction():andThen(print) Copy If you already have a function that yields, and you want it to return a Promise instead, you can use Promise.promisify or Promise.try: local function myYieldingFunction(waitTime, text) wait(waitTime) return textend local myFunction = Promise.promisify(myYieldingFunction)myFunction(1.2, &quot;Hello world!&quot;):andThen(print):catch(function() warn(&quot;Oh no... goodbye world.&quot;)end) Copy "},{"title":"Rejection and Errors","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#rejection-and-errors","content":"You must observe the result of a Promise, either with catch or finally, otherwise an unhandled Promise rejection warning will be printed to the console. If an error occurs while executing the Promise body, the Promise will be rejected automatically with the error text and a trace back. "},{"title":"Chaining","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#chaining","content":"One of the best parts about Promises is that they are chainable. Every time you call andThen, catch, or finally, it returns a new Promise, which resolves with whatever value you return from the success or failure handlers, respectively. somePromise:andThen(function(number) return number + 1end):andThen(print) Copy You can also return a Promise from your handler, and it will be chained onto: Promise.new(function(resolve) somethingThatYields() resolve(1)end):andThen(function(x) return Promise.new(function(resolve) somethingThatYields() resolve(x + 1) end)end):andThen(print) --&gt; 2 Copy You can also call :andThen multiple times on a single Promise to have multiple branches off of a single Promise. Resolving a Promise with a Promise will be chained as well: Promise.new(function(resolve) somethingThatYields() resolve(Promise.new(function(resolve) somethingThatYields() resolve(1) end))end):andThen(print) --&gt; 1 Copy However, any value that is returned from the Promise executor (the function you pass into Promise.new) is discarded. Do not return values from the function executor. "},{"title":"A Better Alternative to spawn, wait, and delay","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#a-better-alternative-to-spawn-wait-and-delay","content":"Using spawn, wait, or delay alongside asynchronous code can be tempting, but you should never use them! spawn, wait, and delay do not resume threads at a consistent interval. If Roblox has resumed too many threads in a single Lua step, it will begin throttling and your thread that was meant to be resumed on the next frame could actually be resumed several seconds later. The unexpected delay caused by this behavior will cause cascading timing issues in your game and could lead to some potentially ugly bugs. You should use Promise.delay instead, which has an accurate custom scheduler. Promise.delay(5):andThen(function() print(&quot;5 seconds have passed!&quot;)end) Copy For quickly launching a new thread (similar to spawn), you can use Promise.try: Promise.try(function() somethingThatYields()end)-- Doesn't block thissomeCode() Copy As a convenience, Promise:timeout exists, which will return a rejected Promise if the Promise you call it on doesn't resolve within the given amount of seconds: returnsAPromise():timeout(5):andThen(function() print(&quot;This returned in at most 5 seconds&quot;)end) Copy "},{"title":"Cancellation","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#cancellation","content":"Promises are cancellable, but abort semantics are optional. This means that you can cancel any Promise and it will never resolve or reject, even if the function is still working in the background. But you can optionally add a cancellation hook which allows you to abort ongoing operations with the third onCancel parameter given to your Promise executor. If a Promise is already cancelled at the time of calling its onCancel hook, the hook will be called immediately. tip It's good practice to add an onCancel hook to all of your asynchronous Promises unless it's impossible to abort an operation safely. Even if you don't plan to directly cancel a particular Promise, chaining with other Promises can cause it to become automatically cancelled if no one cares about the value anymore. If you attach a :andThen or :catch handler to a Promise after it's been cancelled, the chained Promise will be instantly rejected with Promise.Error(Promise.Error.Kind.AlreadyCancelled). This also applies to Promises that you pass to resolve. However, finally does not have this constraint. warning If you cancel a Promise immediately after creating it without yielding in between, the fate of the Promise is dependent on if the Promise handler yields or not. If the Promise handler resolves without yielding, then the Promise will already be settled by the time you are able to cancel it, thus any consumers of the Promise will have already been called and cancellation is not possible. If the Promise does yield, then cancelling it immediately will prevent its resolution. Attempting to cancel an already-settled Promise is ignored. "},{"title":"Cancellation Propagation","type":1,"pageTitle":"Tour of Promises","url":"docs/Tour#cancellation-propagation","content":"When you cancel a Promise, the cancellation propagates up and down the Promise chain. Promises keep a list of other Promises that consume them (e.g. andThen). When the upwards propagation encounters a Promise that no longer has any consumers, that Promise is cancelled as well. Note that it's impossible to cancel an already-settled Promise, so upwards propagation will stop when it reaches a settled Promise. If a cancelled Promise has any consumers itself, those Promises are also cancelled. Resolving a Promise with a Promise will cause the resolving Promise to become a consumer of the chained Promise, so if the chained Promise becomes cancelled then the resolving Promise will also become cancelled. If you call resolve with a Promise within a Promise which is already cancelled, the passed Promise will be cancelled if it has no other consumers as an optimization. "},{"title":"Why use Promises?","type":0,"sectionRef":"#","url":"docs/WhyUsePromises","content":"","keywords":""},{"title":"Threads","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#threads","content":"When writing programs, it's possible to divide functions into two groups: &quot;synchronous&quot; and &quot;asynchronous&quot;. A &quot;synchronous operation&quot; is one that can run to completion and generate any necessary return values with only the information available to your code at the time the operation begins. For example, a function that takes two Parts and returns the distance between them would be synchronous, because all information needed to compute that value is available when you call the function. But sometimes situations arise where we call a function that needs access to a value that doesn't exist at call time. This could be because it requires a network request to get the data, or the user needs to input some text, or we're waiting for another process to finish computation and give us the value. In any case, we refer to this as an &quot;asynchronous operation&quot;. The simplest way to deal with this is to just stop execution of the thread, or &quot;block&quot;. This means that when you call a function that needs some data that doesn't exist yet, the entire thread stops running and waits for the data to be ready before returning and continuing. This is actually how many low-level languages typically model asynchronous operations. To allow tasks to run at the same time, programs will create new threads that branch from parent threads and jump back on when they're finished blocking. However, this presents challenges with sharing memory and synchronizing data across threads, because at the operating system level threads truly are running in parallel. "},{"title":"Coroutines","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#coroutines","content":"To simplify sharing memory and potentially reduce overhead, many programs will emulate a multi-threaded environment using green threads or coroutines, which are run concurrently inside of one OS thread. The key difference between OS threads and coroutines is that coroutines do not actually run in parallel -- only one coroutine is ever executing at a time. In the context of Lua, the term &quot;thread&quot; is used to refer to a coroutine, but they are not the same thing as OS threads. To facilitate this emulation, a thread scheduler is introduced to keep track of the emulated threads and decide which thread to run next when the current thread yields. Yielding is similar to blocking, except when a coroutine yields, it signals to the thread scheduler that it can run other code and resume the thread at a later time. When the game starts, each Script and LocalScript in your game becomes its own Lua thread in the thread scheduler and each script is run either to completion or until it yields. Once all of the scripts have gone through this process, Roblox does other things like updating humanoids and running physics. After all that's done, the next frame begins and this process repeats until the game closes. So, what really happens when we call an asynchronous function like Player:IsInGroup? Well, the current Lua thread yields (letting other Lua code start running elsewhere in your game), and Roblox makes a new OS thread which blocks on an HTTP request to their internal group APIs in the background. Sometime in the future when that request comes back, the value jumps back onto the main Roblox thread and your Lua thread is scheduled to be resumed with the given arguments on the next step. "},{"title":"Problems with the Coroutine Model","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#problems-with-the-coroutine-model","content":"Coroutines fix the memory sharing problem of OS threads, but they still inherit other problems when used on their own: It's impossible to know if a function that you call is going to yield or not unless you look at the documentation or strictly abide by a naming convention (which is not realistic). Unintentionally yielding the thread is the source of a large class of bugs and race conditions that Roblox developers run into.When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same tired patterns many times over for checking if the operation was successful, and make composing multiple asynchronous operations difficult.It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery.Coroutines lack easy access to introspection without manual work to enable it at the call site.Coroutines lack the ability to cancel an operation if the value is no longer needed without extraneous manual work at both the call site and the function implementation. "},{"title":"Enter Promises","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#enter-promises","content":"In Lua, Promises are an abstraction over coroutines. A &quot;Promise&quot; is just an object which we can use to represent a value that exists in the future, but doesn't right now. Promises are first-class citizens in other languages like JavaScript, which doesn't have coroutines and facilitates all asynchronous code through callbacks alone. When calling an asynchronous function, instead of yielding, the function returns a Promise synchronously. The Promise object allows you to then attach a callback function which will be run later when the Promise resolves. The function you called is in charge of resolving the Promise with your value when it is done working. Promises also have built-in error handling. In addition to resolving, a Promise can reject, which means that something went wrong when getting the future value we asked for. You can attach a different callback to be run when the Promise rejects so you can handle any error cases. Let's take a look at this in action. We will make a function which wraps HttpService:GetAsync and instead of yielding, it will return a Promise. local HttpService = game:GetService(&quot;HttpService&quot;)local function httpGet(url) return Promise.new(function(resolve, reject) local ok, result = pcall(HttpService.GetAsync, HttpService, url) if ok then resolve(result) else reject(result) end end)end Copy Let's break this down. The Promise.new function accepts a function, called an executor, which receives a resolve function and a reject function. Promise.new calls the executor on the next Lua step. Inside it, we have created a safe space to safely call yielding functions, which has no possibility of unintentionally delaying other parts of your code. Since the Promise value itself was already returned from the httpGet function, we aren't delaying the return by yielding with GetAsync. Let's use the value now: local promise = httpGet(&quot;https://google.com&quot;) promise:andThen(function(body) print(&quot;Here's the Google homepage:&quot;, body)end) promise:catch(function(err) warn(&quot;We failed to get the Google homepage!&quot;, err)end) Copy So, we call the andThen method on the Promise returned from httpGet. If the Promise resolved, the handler we passed into andThen is called and given the resolved values as parameters (body in this example). Likewise, we attach a failure handler with catch to be run if the Promise rejects. But wait! In addition to attaching a callback, andThen and catch also return new Promises themselves! If the original Promise rejects, then the Promise returned from andThen will also reject with the same error, allowing is to rewrite our code like this: httpGet(&quot;https://google.com&quot;) :andThen(function(body) print(&quot;Here's the Google homepage:&quot;, body) end) :catch(function(err) warn(&quot;We failed to get the Google homepage!&quot;, err) end) Copy The Promise returned from andThen will resolve with whatever value you return from the callback. And if that value returned from the andThen handler is itself a Promise, it is automatically chained onto and the Promise returned from andThen won't resolve until that Promise resolves. httpGet(&quot;https://google.com&quot;) :andThen(function(body) -- not doing anything with body for this example return httpGet(&quot;https://eryn.io&quot;) -- returning a new Promise here! end) :andThen(function(body) -- Doesn't get called until the above Promise resolves! print(&quot;Here's the eryn.io homepage:&quot;, body) end) :catch(warn) -- Still catches errors from both Promises! Copy "},{"title":"Composing Promises","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#composing-promises","content":"Promises are composable. This means that Promises can easily be used, interact with, and consume one another without manually threading values between them. We already saw above how returning a Promise from the andThen handler will chain onto it. Let's expand that idea by diving into some more ways you can compose Promises with each other: Let's assume that we have a number of asynchronous functions which all return Promises, async1, async2, async3, async3, etc. Calling one of these functions will return a Promise. But what if we want to call all of them in sequence, each one after the one before it finishes? It's as simple as this: async1() :andThen(async2) :andThen(async3) :andThen(async4) :andThen(async5) :catch(function(err) warn(&quot;Oh no! This went wrong somewhere along the line:&quot;, err) end) Copy In this sample, we first call async1, then we chain the rest of the functions together with andThen. If any of the Promises returned from these functions reject, then all remaining andThen'd functions are skipped and it will jump instantly to the catch handler. And as a side note, if you forget to add a catch to a long chain of Promises and one of them errors, the Promise library is smart enough to emit a warning in the console. Always catch your Promises! Let's think of another situation. What if we want to run all of the functions concurrently, and wait for all of them to be done? We don't want to run them one after another, because sometimes that can be wasteful. We want them all to run at once! We can do this with the static method Promise.all: Promise.all({ async1(), async2(), async3(), async4()}):andThen(function(arrayOfResolvedValues) print(&quot;Done running all 4 functions!&quot;)end):catch(function(err) warn(&quot;Uh oh, one of the Promises rejected! Abort mission!&quot;)end) Copy Promise.all accepts an array of Promise objects, and returns a new Promise. The new Promise will resolve with an array of resolved values in the same places as the Promises were in the array. The new Promise will reject if any of the Promises that were passed in rejects. Promise.race is similar to Promise.all, except it will resolve or reject as soon as one of the Promises resolves or rejects. We can call functions that return Promises from inside a Promise and safely yield for their result by using the await method of Promises. This is akin to the await keyword in languages like JavaScript. Sometimes it might be easier to just directly resolve with a Promise though, in which case that Promise is chained onto and the outer Promise won't resolve until the inner one does. local function async1() return Promise.new(function(resolve, reject) local ok, value = async2():await() if not ok then return reject(value) end resolve(value + 1) end)end Copy "},{"title":"Wait, nevermind.","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#wait-nevermind","content":"Sometimes, we no longer need a value that we previously asked for (or we just want to stop a sequence of events). This could be for a variety of reasons: perhaps the user closed a menu that was loading, or a player's ability gets interrupted, or a player skips a cutscene. When situations like these come up, we can cancel a Promise. Cancelling a Promise in its simplest form prevents the andThen or catch handlers from running. But we can also optionally attach a hook inside of the Promise executor so we know when the Promise has been cancelled, and stop doing work. There is a third parameter sent to Promise executors, in addition to resolve and reject, called onCancel. onCancel allows you to register a callback which will be called whenever the Promise is cancelled. For example: local function tween(obj, tweenInfo, props) return Promise.new(function(resolve, reject, onCancel) local tween = TweenService:Create(obj, tweenInfo, props) -- Register a callback to be called if the Promise is cancelled. onCancel(function() tween:Cancel() end) tween.Completed:Connect(resolve) tween:Play() end)end -- Begin tweening immediatelylocal promise = tween(workspace.Part, TweenInfo.new(2), { Transparency = 0.5 }):andThen(function() print(&quot;This is never printed.&quot;)end):catch(function() print(&quot;This is never printed.&quot;)end):finally(function() print(&quot;But this *is* printed!&quot;)end)wait(1)promise:cancel() -- Cancel the Promise, which cancels the tween. Copy If we didn't register an onCancel callback, the Promise returned from the tween would never resolve or reject (so the andThen and catch handlers would never get called), but the tween would still finish. For times when we need to do something no matter the fate of the Promise, whether it gets resolved, rejected, or cancelled, we can use finally. finally is like andThen and catch, except it always runs whenever the Promise is done running. "},{"title":"Propagation","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#propagation","content":"Cancelling a Promise will propagate upwards and cancel the entire chain of Promises. So to revisit our sequence example: local promise = async1() :andThen(async2) :andThen(async3) :andThen(async4) :andThen(async5) :catch(function(err) warn(&quot;Oh no! This went wrong somewhere along the line:&quot;, err) end) promise:cancel() Copy Cancelling promise (which is the Promise that catch returns here) will end up cancelling every Promise in the chain, all the way up to the Promise returned by async1. The reason this happens is because if we cancel the bottom-most Promise, we are no longer doing anything with the value, which means that no one is doing anything with the value from the Promise above it either, and so on all the way to the top. However, Promises will not be cancelled if they have more than one andThen handler attached to them, unless all of those are also cancelled. Cancellation also propagates downwards. If a Promise is cancelled, and other Promises are dependent on that Promise, there's no way they could resolve or reject anymore, so they are cancelled as well. So, now we understand the four possible states a Promise can be in: Started (running), Resolved, Rejected, and Cancelled. It's possible to read what state a Promise is in by calling promise:getStatus(). "},{"title":"But I want to be able to use pre-existing functions that yield!","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#but-i-want-to-be-able-to-use-pre-existing-functions-that-yield","content":"You can easily turn a yielding function into a Promise-returning one by calling Promise.promisify on it: -- Assuming myFunctionAsync is a function that yields.local myFunction = Promise.promisify(myFunctionAsync) myFunction(&quot;some&quot;, &quot;arguments&quot;):andThen(print):catch(warn) Copy "},{"title":"Problems, revisited","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#problems-revisited","content":"Now, let's revisit the problems we laid about before and see if we've solved them by using Promises: It's impossible to know if a function that you call is going to yield or not. Calling a function that returns a Promise will never yield! To use the value, we must call andThen or await, so we are sure that the caller knows that this is an asynchronous operation. When an asynchronous operation fails or an error is encountered, Lua functions usually either raise an error or return a success value followed by the actual value. Both of these methods lead to repeating the same patterns. We have Promise:catch to allow catching errors that will cascade down a Promise chain and jump to the nearest catch handler. It is difficult to deal with running multiple asynchronous operations concurrently and then retrieve all of their values at the end without extraneous machinery. We have Promise.all, Promise.race, or other utilities to make this a breeze. Coroutines lack easy access to introspection without manual work to enable it at the call site. We can just call :getStatus on the returned Promise! Coroutines lack the ability to cancel an operation if the value is no longer needed without extraneous manual work at both the call site and the function implementation. promise:cancel() is all we need! Another point that's important to drive home is that you can do all of these things without Promises, but they require duplicated work each time you do them, which makes them incompatible with each other and that allows for slight differences between implementations which can lead to usage mistakes. Centralizing and abstracting all of this logic by using Promises ensures that all of your asynchronous APIs will be consistent and composable with one another. "},{"title":"Next steps","type":1,"pageTitle":"Why use Promises?","url":"docs/WhyUsePromises#next-steps","content":"Now that you are hopefully convinced of the benefits of using Promises in your code, move on to the Guide for a quick introduction, or dive in to the API reference "},{"title":"Promise","type":0,"sectionRef":"#","url":"api/Promise","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Promise","url":"api/Promise#types","content":" "},{"title":"Status","type":1,"pageTitle":"Promise","url":"api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. "},{"title":"Properties","type":1,"pageTitle":"Promise","url":"api/Promise#properties","content":" "},{"title":"Status","type":1,"pageTitle":"Promise","url":"api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. "},{"title":"Functions","type":1,"pageTitle":"Promise","url":"api/Promise#functions","content":" "},{"title":"all","type":1,"pageTitle":"Promise","url":"api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. info Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   "},{"title":"allSettled","type":1,"pageTitle":"Promise","url":"api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   "},{"title":"any","type":1,"pageTitle":"Promise","url":"api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   "},{"title":"defer","type":1,"pageTitle":"Promise","url":"api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler: () → boolean) ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   "},{"title":"delay","type":1,"pageTitle":"Promise","url":"api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. warning Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   "},{"title":"each","type":1,"pageTitle":"Promise","url":"api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. info Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  "},{"title":"fold","type":1,"pageTitle":"Promise","url":"api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   "},{"title":"fromEvent","type":1,"pageTitle":"Promise","url":"api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. tip This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   "},{"title":"is","type":1,"pageTitle":"Promise","url":"api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  "},{"title":"new","type":1,"pageTitle":"Promise","url":"api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: ( resolve: (...: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler: () → boolean) ) → ()) → (), reject: (...: any) → (), onCancel: (abortHandler: () → boolean) ) → ()) → (), reject: (...: any) → (), onCancel: (abortHandler: () → boolean) ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not.  "},{"title":"promisify","type":1,"pageTitle":"Promise","url":"api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. info Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   "},{"title":"race","type":1,"pageTitle":"Promise","url":"api/Promise#race","content":"&lt;/&gt; Promise.race(promises:: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. warning If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   "},{"title":"reject","type":1,"pageTitle":"Promise","url":"api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. caution Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   "},{"title":"resolve","type":1,"pageTitle":"Promise","url":"api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value.  "},{"title":"retry","type":1,"pageTitle":"Promise","url":"api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → () Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   "},{"title":"some","type":1,"pageTitle":"Promise","url":"api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   "},{"title":"try","type":1,"pageTitle":"Promise","url":"api/Promise#try","content":"&lt;/&gt; Promise.try(callback: (...: any) → ...any) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. info Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   "},{"title":"andThen","type":1,"pageTitle":"Promise","url":"api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Return a Promise from the success or failure handler and it will be chained onto.  "},{"title":"andThenCall","type":1,"pageTitle":"Promise","url":"api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   "},{"title":"andThenReturn","type":1,"pageTitle":"Promise","url":"api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) caution Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].  "},{"title":"await","type":1,"pageTitle":"Promise","url":"api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. caution If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   "},{"title":"awaitStatus","type":1,"pageTitle":"Promise","url":"api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  "},{"title":"cancel","type":1,"pageTitle":"Promise","url":"api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   "},{"title":"catch","type":1,"pageTitle":"Promise","url":"api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. warning Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first.  "},{"title":"done","type":1,"pageTitle":"Promise","url":"api/Promise#done","content":"&lt;/&gt; Promise:done(doneHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to finally, except it doesn't catch rejections. caution done should be reserved specifically when you want to perform some operation after the Promise is finished (like finally), but you don't want to consume rejections (like in this example). You should use andThen instead if you only care about the Resolved case. warning Like finally, if the Promise is cancelled, any Promises chained off of it with andThen won't run. Only Promises chained with done and finally will run in the case of cancellation. Returns a new promise chained from this promise.  "},{"title":"doneCall","type":1,"pageTitle":"Promise","url":"api/Promise#doneCall","content":"&lt;/&gt; Promise:doneCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for done. Attaches a done handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"doneReturn","type":1,"pageTitle":"Promise","url":"api/Promise#doneReturn","content":"&lt;/&gt; Promise:doneReturn( ...: any-- Values to return from the function ) → Promise Attaches a done handler to this Promise that discards the resolved value and returns the given value from it. promise:doneReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:done(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"expect","type":1,"pageTitle":"Promise","url":"api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. "},{"title":"Errors","type":1,"pageTitle":"Promise","url":"api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  "},{"title":"finally","type":1,"pageTitle":"Promise","url":"api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new promise chained from this promise. caution If the Promise is cancelled, any Promises chained off of it with andThen won't run. Only Promises chained with finally or done will run in the case of cancellation. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   "},{"title":"finallyCall","type":1,"pageTitle":"Promise","url":"api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  "},{"title":"finallyReturn","type":1,"pageTitle":"Promise","url":"api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   "},{"title":"getStatus","type":1,"pageTitle":"Promise","url":"api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  "},{"title":"now","type":1,"pageTitle":"Promise","url":"api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [[Error.isKind]].  "},{"title":"tap","type":1,"pageTitle":"Promise","url":"api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  "},{"title":"timeout","type":1,"pageTitle":"Promise","url":"api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [[Error.isKind]]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })  "}]