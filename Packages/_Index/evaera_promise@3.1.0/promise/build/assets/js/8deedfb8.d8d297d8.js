"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[556],{26437:function(e,i,n){n.r(i),n.d(i,{frontMatter:function(){return o},contentTitle:function(){return d},metadata:function(){return m},toc:function(){return s},default:function(){return k}});var t=n(87462),a=n(63366),l=(n(67294),n(3905)),r=["components"],o={},d="Changelog",m={type:"mdx",permalink:"/roblox-lua-promise/CHANGELOG",source:"@site/pages/CHANGELOG.md"},s=[{value:"3.1.0 - 2020-12-01",id:"310---2020-12-01",children:[{value:"Added",id:"added",children:[]}]},{value:"3.0.1 - 2020-08-24",id:"301---2020-08-24",children:[{value:"Fixed",id:"fixed",children:[]}]},{value:"3.0.0 - 2020-08-17",id:"300---2020-08-17",children:[{value:"Changed",id:"changed",children:[]}]},{value:"3.0.0-rc.3 - 2020-07-10",id:"300-rc3---2020-07-10",children:[{value:"Fixed",id:"fixed-1",children:[]}]},{value:"3.0.0-rc.1 - 2020-06-02",id:"300-rc1---2020-06-02",children:[{value:"Changed",id:"changed-1",children:[]},{value:"Added",id:"added-1",children:[]},{value:"Fixed",id:"fixed-2",children:[]}]},{value:"2.5.1",id:"251",children:[]},{value:"2.5.0",id:"250",children:[]},{value:"2.4.0",id:"240",children:[]},{value:"2.3.1",id:"231",children:[]},{value:"2.3.0",id:"230",children:[]},{value:"2.2.0",id:"220",children:[]},{value:"2.1.0",id:"210",children:[]},{value:"2.0.0",id:"200",children:[]}],u={toc:s};function k(e){var i=e.components,n=(0,a.Z)(e,r);return(0,l.kt)("wrapper",(0,t.Z)({},u,n,{components:i,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"changelog"},"Changelog"),(0,l.kt)("h2",{id:"310---2020-12-01"},"[3.1.0]"," - 2020-12-01"),(0,l.kt)("h3",{id:"added"},"Added"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Added ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.fold")," (#47)")),(0,l.kt)("h2",{id:"301---2020-08-24"},"[3.0.1]"," - 2020-08-24"),(0,l.kt)("h3",{id:"fixed"},"Fixed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Make ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.is")," work with promises from old versions of the library (#41)"),(0,l.kt)("li",{parentName:"ul"},"Make ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.delay")," properly break out of the current loop (#40)"),(0,l.kt)("li",{parentName:"ul"},"Allow upvalues captured by queued callbacks to be garbage collected when the Promise resolves by deleting the queues when the Promise settles (#39)")),(0,l.kt)("h2",{id:"300---2020-08-17"},"[3.0.0]"," - 2020-08-17"),(0,l.kt)("h3",{id:"changed"},"Changed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.delay")," now uses ",(0,l.kt)("inlineCode",{parentName:"li"},"os.clock")),(0,l.kt)("li",{parentName:"ul"},"Made ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.delay")," behavior more consistent when creating new timers in the callback of a timer.")),(0,l.kt)("h2",{id:"300-rc3---2020-07-10"},"[3.0.0-rc.3]"," - 2020-07-10"),(0,l.kt)("h3",{id:"fixed-1"},"Fixed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Fixed a bug where queued ",(0,l.kt)("inlineCode",{parentName:"li"},"andThen")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"catch")," callbacks did not begin on their own new threads.")),(0,l.kt)("h2",{id:"300-rc1---2020-06-02"},"[3.0.0-rc.1]"," - 2020-06-02"),(0,l.kt)("h3",{id:"changed-1"},"Changed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Runtime errors are now represented by objects. You must call tostring on rejection values before assuming they are strings (this was always good practice, but is required now)."),(0,l.kt)("li",{parentName:"ul"},"Yielding is now allowed in ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.new"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"andThen"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.try")," executors."),(0,l.kt)("li",{parentName:"ul"},"Errors now have much better stack traces due to using ",(0,l.kt)("inlineCode",{parentName:"li"},"xpcall")," internally instead of ",(0,l.kt)("inlineCode",{parentName:"li"},"pcall"),"."),(0,l.kt)("li",{parentName:"ul"},"Stack traces will now be more direct and not include as many internal calls within the Promise library."),(0,l.kt)("li",{parentName:"ul"},"Chained promises from ",(0,l.kt)("inlineCode",{parentName:"li"},"resolve()")," or returning from andThen now have improved rejection messages for debugging."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.async")," has been renamed to ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.defer")," (",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.async")," references same function for compatibility)"),(0,l.kt)("li",{parentName:"ul"},"Promises now have a ",(0,l.kt)("inlineCode",{parentName:"li"},"__tostring")," metamethod, which returns ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise(Resolved)")," or whatever the current status is."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise:timeout()")," now rejects with a ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.Error(Promise.Error.Kind.TimedOut)")," object. (Formerly rejected with the string ",(0,l.kt)("inlineCode",{parentName:"li"},'"Timed out"'),")"),(0,l.kt)("li",{parentName:"ul"},"Attaching a handler to a cancelled Promise now rejects with a ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.Error(Promise.Error.Kind.AlreadyCancelled)"),". (Formerly rejected with the string ",(0,l.kt)("inlineCode",{parentName:"li"},'"Promise is cancelled"'),")"),(0,l.kt)("li",{parentName:"ul"},"Let ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise:expect()")," throw rejection objects")),(0,l.kt)("h3",{id:"added-1"},"Added"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"New Promise Error class is exposed at ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.Error"),", which includes helpful static methods like ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.Error.is"),"."),(0,l.kt)("li",{parentName:"ul"},"Added ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise:now()")," (#23)"),(0,l.kt)("li",{parentName:"ul"},"Added ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.each")," (#21)"),(0,l.kt)("li",{parentName:"ul"},"Added ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.retry")," (#16)"),(0,l.kt)("li",{parentName:"ul"},"Added ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.fromEvent")," (#14)"),(0,l.kt)("li",{parentName:"ul"},"Improved test coverage for asynchronous and time-driven functions")),(0,l.kt)("h3",{id:"fixed-2"},"Fixed"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Changed ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.is")," to be safe when dealing with tables that have an ",(0,l.kt)("inlineCode",{parentName:"li"},"__index")," metamethod that creates an error."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.delay")," resolve value (time passed) is now more accurate (previously passed time based on when we started resuming threads instead of the current time. This is a very minor difference.)")),(0,l.kt)("h2",{id:"251"},"[2.5.1]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Fix issue with rejecting with non-string not propagating correctly.")),(0,l.kt)("h2",{id:"250"},"[2.5.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Add Promise.tap"),(0,l.kt)("li",{parentName:"ul"},"Fix bug with C functions not working when passed to andThen"),(0,l.kt)("li",{parentName:"ul"},"Fix issue with Promise.race/all always cancelling instead of only cancelling if the Promise has no other consumers"),(0,l.kt)("li",{parentName:"ul"},"Make error checking more robust across many methods."),(0,l.kt)("li",{parentName:"ul"},"Promise.Status members are now strings instead of symbols, and indexing a non-existent value will error."),(0,l.kt)("li",{parentName:"ul"},"Improve stack traces"),(0,l.kt)("li",{parentName:"ul"},"Promise.promisify will now turn errors into rejections even if they occur after a yield."),(0,l.kt)("li",{parentName:"ul"},"Add Promise.try"),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"done"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"doneCall"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"doneReturn")),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"andThenReturn"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"finallyReturn")),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.delay"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"promise:timeout")),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.some"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.any")),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.allSettled")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.all")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.race")," are now cancellable.")),(0,l.kt)("h2",{id:"240"},"[2.4.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.is"),' now only checks if the object is "andThennable" (has an ',(0,l.kt)("inlineCode",{parentName:"li"},"andThen")," method).")),(0,l.kt)("h2",{id:"231"},"[2.3.1]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Make unhandled rejection warning trigger on next Heartbeat")),(0,l.kt)("h2",{id:"230"},"[2.3.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Remove ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.spawn")," from the public API."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.async")," still inherits the behavior from ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.spawn"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.async")," now wraps the callback in ",(0,l.kt)("inlineCode",{parentName:"li"},"pcall")," and rejects if an error occurred."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.new")," has now has an explicit error message when attempting to yield inside of it.")),(0,l.kt)("h2",{id:"220"},"[2.2.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Promise.promisify")," now uses ",(0,l.kt)("inlineCode",{parentName:"li"},"coroutine.wrap")," instead of ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise.spawn"))),(0,l.kt)("h2",{id:"210"},"[2.1.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"finallyCall"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"andThenCall")),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"awaitValue"))),(0,l.kt)("h2",{id:"200"},"[2.0.0]"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Add Promise.race"),(0,l.kt)("li",{parentName:"ul"},"Add Promise.async"),(0,l.kt)("li",{parentName:"ul"},"Add Promise.spawn"),(0,l.kt)("li",{parentName:"ul"},"Add Promise.promisify"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"finally")," now silences the unhandled rejection warning"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onCancel")," now returns if the Promise was cancelled at call time."),(0,l.kt)("li",{parentName:"ul"},"Cancellation now propagates downstream."),(0,l.kt)("li",{parentName:"ul"},"Add ",(0,l.kt)("inlineCode",{parentName:"li"},"Promise:awaitStatus")),(0,l.kt)("li",{parentName:"ul"},"Calling ",(0,l.kt)("inlineCode",{parentName:"li"},"resolve")," with a Promise while the resolving Promise is cancelled instantly cancels the passed Promise as an optimization."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"finally")," now passes the Promise status as a parameter.")))}k.isMDXComponent=!0}}]);